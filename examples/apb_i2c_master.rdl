/* apb_i2c SystemRDL */

addrmap apb_i2c #(longint unsigned WIDTH = 32) {
    name = "APB I2C Address Map";

    default regwidth = WIDTH;

    reg {
        name = "STATUS";
        desc = "I2C status register";

        field {
            name = "busy";
            desc = "High when module is performing an I2C operation";
            sw = r; hw = w;} busy = 0;
            
        field {
            name = "bus_cont";
            desc = "High when module has control of active bus";
            sw = r; hw = w;} bus_cont = 0;

        field {
            name = "bus_active";
            desc = "High when bus is active";
            sw = r; hw = w;} bus_act = 0;

        field {
            name = "miss_ack";
            desc = "set high when an ACK pulse from a slave device is not seen; write 1 to clear";
            sw = rw; hw = w;} miss_ack = 0;

        field {
            name = "cmd_empty";
            desc = "Command FIFO empty";
            sw = r; hw = w;} cmd_empty[8:8] = 0;

        field {
            name = "cmd_full";
            desc = "Command FIFO full";
            sw = r; hw = w;} cmd_full = 0;

        field {
            name = "cmd_ovf";
            desc = "Command FIFO overflow; write 1 to clear";
            sw = rw; hw = w;} cmd_ovf = 0;

        field {
            name = "wr_empty";
            desc = "Write data FIFO empty";
            sw = r; hw = w;} wr_empty = 0;

        field {
            name = "wr_full";
            desc = "Write data FIFO full";
            sw = r; hw = w;} wr_full = 0;

        field {
            name = "wr_ovf";
            desc = "Write data FIFO overflow; write 1 to clear";
            sw = rw; hw = w;} wr_ovf = 0;

        field {
            name = "rd_empty";
            desc = "Read data FIFO is empty";
            sw = r; hw = w;} rd_empty = 0;

        field {
            name = "rd_full";
            desc = "Read data FIFO is full";
            sw = r; hw = w;} rd_full = 0;

    } status_reg @ 0x00;

    reg {
        name = "COMMAND";
        desc = "Controls the operation of I2C
                Setting more than one command bit is allowed.  Start or repeated start
                will be issued first, followed by read or write, followed by stop.  Note
                that setting read and write at the same time is not allowed, this will
                result in the command being ignored.";

        field {
            name = "cmd_address";
            desc = "Address to be written on the I2C bus";
            sw = rw; hw = r;} cmd_address[6:0] = 0;

        field {
            name = "cmd_start";
            desc = "Set high to issue I2C start, write to push on command FIFO";
            sw = rw; hw = r;} cmd_start = 0;

        field {
            name = "cmd_read";
            desc = "Set high to start read, write to push on command FIFO";
            sw = rw; hw = r;} cmd_read= 0;

        field {
            name = "cmd_write";
            desc = "Set high to start write, write to push on command FIFO";
            sw = rw; hw = r;} cmd_write = 0;

        field {
            name = "cmd_write_multiple";
            desc = "Set high to start block write, write to push on command FIFO";
            sw = rw; hw = r;} cmd_write_multiple = 0;

        field {
            name = "cmd_stop";
            desc = "Set high to issue I2C stop, write to push on command FIFO";
            sw = rw; hw = r;} cmd_stop = 0;

    } command_reg @ 0x04;

    reg {
        name = "DATA";
        desc = "Send and receive data register";

        field {
            name = "data";
            desc = "I2C data, write to push on write data FIFO, read to pull from read data FIFO";
            sw = rw; hw = r;} data[7:0] = 0;

        field {
            name = "data_valid";
            desc = "Indicates valid read data, must be accessed with atomic 16 bit reads and writes";
            sw = rw; hw = r;} data_valid = 0;

        field {
            name = "data_last";
            desc = "Indicate last byte of block write (write_multiple), must be accessed with atomic 16 bit reads and writes";
            sw = rw; hw = r;} data_last = 0;

    } data_reg @ 0x08;

    reg {
        name = "PRESCALE";
        desc = "Set prescale value. Set prescale to 1/4 of the minimum clock period in units of input clk cycles";

        field {
            name = "prescale";
            desc = "Prescale = Fclk / (FI2Cclk * 4)";
            sw = rw; hw = r;} prescale[15:0] = 0;

    } prescale_reg @ 0x0C;
};
